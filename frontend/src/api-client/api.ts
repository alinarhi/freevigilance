/* tslint:disable */
/* eslint-disable */
/**
 * Freevigilance API
 * PVA Management Application for Pharmaceutical Companies.
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * * `0` - create * `1` - update * `2` - delete * `3` - access
 * @export
 * @enum {number}
 */

export const ActionEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;

export type ActionEnum = typeof ActionEnum[keyof typeof ActionEnum];


/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'created_by_display'?: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'text': string;
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    'created_by'?: number;
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    'task'?: number;
}
/**
 * * `D` - Ежедневно * `W` - Каждую неделю * `M` - Каждый месяц * `Y` - Каждый год
 * @export
 * @enum {string}
 */

export const FrequencyTypeEnum = {
    D: 'D',
    W: 'W',
    M: 'M',
    Y: 'Y'
} as const;

export type FrequencyTypeEnum = typeof FrequencyTypeEnum[keyof typeof FrequencyTypeEnum];


/**
 * 
 * @export
 * @interface LogEntry
 */
export interface LogEntry {
    /**
     * 
     * @type {number}
     * @memberof LogEntry
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    'actor_display'?: string;
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    'content_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    'content_type_display'?: string;
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    'action_display'?: string;
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    'object_pk': string;
    /**
     * 
     * @type {number}
     * @memberof LogEntry
     */
    'object_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    'object_repr': string;
    /**
     * 
     * @type {any}
     * @memberof LogEntry
     */
    'serialized_data'?: any | null;
    /**
     * 
     * @type {ActionEnum}
     * @memberof LogEntry
     */
    'action': ActionEnum;
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    'changes_text'?: string;
    /**
     * 
     * @type {any}
     * @memberof LogEntry
     */
    'changes'?: any | null;
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    'cid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    'remote_addr'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    'timestamp'?: string;
    /**
     * 
     * @type {any}
     * @memberof LogEntry
     */
    'additional_data'?: any | null;
    /**
     * 
     * @type {number}
     * @memberof LogEntry
     */
    'actor'?: number | null;
}


/**
 * 
 * @export
 * @interface MedicinalProduct
 */
export interface MedicinalProduct {
    /**
     * 
     * @type {number}
     * @memberof MedicinalProduct
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof MedicinalProduct
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof MedicinalProduct
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface Obligation
 */
export interface Obligation {
    /**
     * 
     * @type {number}
     * @memberof Obligation
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Obligation
     */
    'pva_display'?: string;
    /**
     * 
     * @type {string}
     * @memberof Obligation
     */
    'responsibility_type': string;
    /**
     * 
     * @type {string}
     * @memberof Obligation
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Obligation
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Obligation
     */
    'start_date': string;
    /**
     * 
     * @type {string}
     * @memberof Obligation
     */
    'end_date': string;
    /**
     * 
     * @type {number}
     * @memberof Obligation
     */
    'pva': number;
}
/**
 * 
 * @export
 * @interface PVA
 */
export interface PVA {
    /**
     * 
     * @type {number}
     * @memberof PVA
     */
    'id'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof PVA
     */
    'medicinal_products': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PVA
     */
    'status_display'?: string;
    /**
     * 
     * @type {string}
     * @memberof PVA
     */
    'requisites': string;
    /**
     * 
     * @type {string}
     * @memberof PVA
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PVA
     */
    'pva_link'?: string;
    /**
     * 
     * @type {string}
     * @memberof PVA
     */
    'main_contract_link'?: string;
    /**
     * 
     * @type {PVAStatusEnum}
     * @memberof PVA
     */
    'status'?: PVAStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PVA
     */
    'start_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PVA
     */
    'end_date'?: string | null;
}


/**
 * * `PLANNED` - Планируемый * `ACTIVE` - Заключен * `ENDING` - Завершающийся * `COMPLETED` - Завершен
 * @export
 * @enum {string}
 */

export const PVAStatusEnum = {
    Planned: 'PLANNED',
    Active: 'ACTIVE',
    Ending: 'ENDING',
    Completed: 'COMPLETED'
} as const;

export type PVAStatusEnum = typeof PVAStatusEnum[keyof typeof PVAStatusEnum];


/**
 * 
 * @export
 * @interface PatchedMedicinalProduct
 */
export interface PatchedMedicinalProduct {
    /**
     * 
     * @type {number}
     * @memberof PatchedMedicinalProduct
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedMedicinalProduct
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMedicinalProduct
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface PatchedObligation
 */
export interface PatchedObligation {
    /**
     * 
     * @type {number}
     * @memberof PatchedObligation
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedObligation
     */
    'pva_display'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedObligation
     */
    'responsibility_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedObligation
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedObligation
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedObligation
     */
    'start_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedObligation
     */
    'end_date'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedObligation
     */
    'pva'?: number;
}
/**
 * 
 * @export
 * @interface PatchedPVA
 */
export interface PatchedPVA {
    /**
     * 
     * @type {number}
     * @memberof PatchedPVA
     */
    'id'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof PatchedPVA
     */
    'medicinal_products'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PatchedPVA
     */
    'status_display'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPVA
     */
    'requisites'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPVA
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPVA
     */
    'pva_link'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPVA
     */
    'main_contract_link'?: string;
    /**
     * 
     * @type {PVAStatusEnum}
     * @memberof PatchedPVA
     */
    'status'?: PVAStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedPVA
     */
    'start_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPVA
     */
    'end_date'?: string | null;
}


/**
 * 
 * @export
 * @interface PatchedResponsibilityType
 */
export interface PatchedResponsibilityType {
    /**
     * 
     * @type {number}
     * @memberof PatchedResponsibilityType
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedResponsibilityType
     */
    'title'?: string;
}
/**
 * 
 * @export
 * @interface PatchedTask
 */
export interface PatchedTask {
    /**
     * 
     * @type {number}
     * @memberof PatchedTask
     */
    'id'?: number;
    /**
     * 
     * @type {TaskSchedule}
     * @memberof PatchedTask
     */
    'schedule'?: TaskSchedule;
    /**
     * 
     * @type {string}
     * @memberof PatchedTask
     */
    'status_display'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedTask
     */
    'created_by_display'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedTask
     */
    'assigned_to_display'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedTask
     */
    'obligation_display'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedTask
     */
    'pva_display'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedTask
     */
    'responsibility_type_display'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedTask
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedTask
     */
    'description'?: string;
    /**
     * 
     * @type {TaskStatusEnum}
     * @memberof PatchedTask
     */
    'status'?: TaskStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedTask
     */
    'deadline'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedTask
     */
    'is_recurring'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedTask
     */
    'completion_evidence_link'?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedTask
     */
    'created_by'?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedTask
     */
    'assigned_to'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedTask
     */
    'obligation'?: number;
}


/**
 * 
 * @export
 * @interface PatchedUser
 */
export interface PatchedUser {
    /**
     * 
     * @type {number}
     * @memberof PatchedUser
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'last_login'?: string | null;
    /**
     * Указывает, что пользователь имеет все права без явного их назначения.
     * @type {boolean}
     * @memberof PatchedUser
     */
    'is_superuser'?: boolean;
    /**
     * Обязательное поле. Не более 150 символов. Только буквы, цифры и символы @/./+/-/_.
     * @type {string}
     * @memberof PatchedUser
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'email'?: string;
    /**
     * Отметьте, если пользователь может входить в административную часть сайта.
     * @type {boolean}
     * @memberof PatchedUser
     */
    'is_staff'?: boolean;
    /**
     * Отметьте, если пользователь должен считаться активным. Уберите эту отметку вместо удаления учётной записи.
     * @type {boolean}
     * @memberof PatchedUser
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    'date_joined'?: string;
}
/**
 * 
 * @export
 * @interface ResponsibilityType
 */
export interface ResponsibilityType {
    /**
     * 
     * @type {number}
     * @memberof ResponsibilityType
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ResponsibilityType
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'id'?: number;
    /**
     * 
     * @type {TaskSchedule}
     * @memberof Task
     */
    'schedule'?: TaskSchedule;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'status_display'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'created_by_display'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'assigned_to_display'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'obligation_display'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'pva_display'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'responsibility_type_display'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'description'?: string;
    /**
     * 
     * @type {TaskStatusEnum}
     * @memberof Task
     */
    'status'?: TaskStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'deadline': string;
    /**
     * 
     * @type {boolean}
     * @memberof Task
     */
    'is_recurring'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'completion_evidence_link'?: string;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'created_by'?: number;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'assigned_to'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'obligation': number;
}


/**
 * 
 * @export
 * @interface TaskSchedule
 */
export interface TaskSchedule {
    /**
     * 
     * @type {number}
     * @memberof TaskSchedule
     */
    'id'?: number;
    /**
     * 
     * @type {FrequencyTypeEnum}
     * @memberof TaskSchedule
     */
    'frequency_type'?: FrequencyTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof TaskSchedule
     */
    'day_of_week'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TaskSchedule
     */
    'week_of_month'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TaskSchedule
     */
    'day_of_month'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TaskSchedule
     */
    'month_of_year'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TaskSchedule
     */
    'start_date': string;
    /**
     * 
     * @type {string}
     * @memberof TaskSchedule
     */
    'end_date': string;
}


/**
 * 
 * @export
 * @interface TaskStatus
 */
export interface TaskStatus {
    /**
     * 
     * @type {TaskStatusEnum}
     * @memberof TaskStatus
     */
    'status': TaskStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof TaskStatus
     */
    'completion_evidence_link'?: string;
}


/**
 * * `NOT_STARTED` - Не начата * `IN_PROGRESS` - В работе * `COMPLETED` - Завершена * `HIDDEN` - Скрыта
 * @export
 * @enum {string}
 */

export const TaskStatusEnum = {
    NotStarted: 'NOT_STARTED',
    InProgress: 'IN_PROGRESS',
    Completed: 'COMPLETED',
    Hidden: 'HIDDEN'
} as const;

export type TaskStatusEnum = typeof TaskStatusEnum[keyof typeof TaskStatusEnum];


/**
 * 
 * @export
 * @interface TokenObtainPair
 */
export interface TokenObtainPair {
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'access'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenObtainPair
     */
    'refresh'?: string;
}
/**
 * 
 * @export
 * @interface TokenRefresh
 */
export interface TokenRefresh {
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'access'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenRefresh
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_login'?: string | null;
    /**
     * Указывает, что пользователь имеет все права без явного их назначения.
     * @type {boolean}
     * @memberof User
     */
    'is_superuser'?: boolean;
    /**
     * Обязательное поле. Не более 150 символов. Только буквы, цифры и символы @/./+/-/_.
     * @type {string}
     * @memberof User
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * Отметьте, если пользователь может входить в административную часть сайта.
     * @type {boolean}
     * @memberof User
     */
    'is_staff'?: boolean;
    /**
     * Отметьте, если пользователь должен считаться активным. Уберите эту отметку вместо удаления учётной записи.
     * @type {boolean}
     * @memberof User
     */
    'is_active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'date_joined'?: string;
}

/**
 * AuditlogApi - axios parameter creator
 * @export
 */
export const AuditlogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AuditlogListActionEnum} [action] * &#x60;0&#x60; - create * &#x60;1&#x60; - update * &#x60;2&#x60; - delete * &#x60;3&#x60; - access
         * @param {string} [actorLastNameIcontains] 
         * @param {string} [actorUsernameIexact] 
         * @param {string} [contentTypeModelIexact] 
         * @param {number} [objectId] 
         * @param {string} [timestampGte] 
         * @param {string} [timestampLte] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditlogList: async (action?: AuditlogListActionEnum, actorLastNameIcontains?: string, actorUsernameIexact?: string, contentTypeModelIexact?: string, objectId?: number, timestampGte?: string, timestampLte?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auditlog/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (actorLastNameIcontains !== undefined) {
                localVarQueryParameter['actor__last_name__icontains'] = actorLastNameIcontains;
            }

            if (actorUsernameIexact !== undefined) {
                localVarQueryParameter['actor__username__iexact'] = actorUsernameIexact;
            }

            if (contentTypeModelIexact !== undefined) {
                localVarQueryParameter['content_type__model__iexact'] = contentTypeModelIexact;
            }

            if (objectId !== undefined) {
                localVarQueryParameter['object_id'] = objectId;
            }

            if (timestampGte !== undefined) {
                localVarQueryParameter['timestamp__gte'] = (timestampGte as any instanceof Date) ?
                    (timestampGte as any).toISOString() :
                    timestampGte;
            }

            if (timestampLte !== undefined) {
                localVarQueryParameter['timestamp__lte'] = (timestampLte as any instanceof Date) ?
                    (timestampLte as any).toISOString() :
                    timestampLte;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuditlogApi - functional programming interface
 * @export
 */
export const AuditlogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuditlogApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AuditlogListActionEnum} [action] * &#x60;0&#x60; - create * &#x60;1&#x60; - update * &#x60;2&#x60; - delete * &#x60;3&#x60; - access
         * @param {string} [actorLastNameIcontains] 
         * @param {string} [actorUsernameIexact] 
         * @param {string} [contentTypeModelIexact] 
         * @param {number} [objectId] 
         * @param {string} [timestampGte] 
         * @param {string} [timestampLte] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async auditlogList(action?: AuditlogListActionEnum, actorLastNameIcontains?: string, actorUsernameIexact?: string, contentTypeModelIexact?: string, objectId?: number, timestampGte?: string, timestampLte?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LogEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.auditlogList(action, actorLastNameIcontains, actorUsernameIexact, contentTypeModelIexact, objectId, timestampGte, timestampLte, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuditlogApi.auditlogList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuditlogApi - factory interface
 * @export
 */
export const AuditlogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuditlogApiFp(configuration)
    return {
        /**
         * 
         * @param {AuditlogListActionEnum} [action] * &#x60;0&#x60; - create * &#x60;1&#x60; - update * &#x60;2&#x60; - delete * &#x60;3&#x60; - access
         * @param {string} [actorLastNameIcontains] 
         * @param {string} [actorUsernameIexact] 
         * @param {string} [contentTypeModelIexact] 
         * @param {number} [objectId] 
         * @param {string} [timestampGte] 
         * @param {string} [timestampLte] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auditlogList(action?: AuditlogListActionEnum, actorLastNameIcontains?: string, actorUsernameIexact?: string, contentTypeModelIexact?: string, objectId?: number, timestampGte?: string, timestampLte?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<LogEntry>> {
            return localVarFp.auditlogList(action, actorLastNameIcontains, actorUsernameIexact, contentTypeModelIexact, objectId, timestampGte, timestampLte, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuditlogApi - object-oriented interface
 * @export
 * @class AuditlogApi
 * @extends {BaseAPI}
 */
export class AuditlogApi extends BaseAPI {
    /**
     * 
     * @param {AuditlogListActionEnum} [action] * &#x60;0&#x60; - create * &#x60;1&#x60; - update * &#x60;2&#x60; - delete * &#x60;3&#x60; - access
     * @param {string} [actorLastNameIcontains] 
     * @param {string} [actorUsernameIexact] 
     * @param {string} [contentTypeModelIexact] 
     * @param {number} [objectId] 
     * @param {string} [timestampGte] 
     * @param {string} [timestampLte] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuditlogApi
     */
    public auditlogList(action?: AuditlogListActionEnum, actorLastNameIcontains?: string, actorUsernameIexact?: string, contentTypeModelIexact?: string, objectId?: number, timestampGte?: string, timestampLte?: string, options?: RawAxiosRequestConfig) {
        return AuditlogApiFp(this.configuration).auditlogList(action, actorLastNameIcontains, actorUsernameIexact, contentTypeModelIexact, objectId, timestampGte, timestampLte, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AuditlogListActionEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
} as const;
export type AuditlogListActionEnum = typeof AuditlogListActionEnum[keyof typeof AuditlogListActionEnum];


/**
 * MedicinalProductsApi - axios parameter creator
 * @export
 */
export const MedicinalProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MedicinalProduct} medicinalProduct 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        medicinalProductsCreate: async (medicinalProduct: MedicinalProduct, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'medicinalProduct' is not null or undefined
            assertParamExists('medicinalProductsCreate', 'medicinalProduct', medicinalProduct)
            const localVarPath = `/api/medicinal-products/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(medicinalProduct, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Лекарственный препарат.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        medicinalProductsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('medicinalProductsDestroy', 'id', id)
            const localVarPath = `/api/medicinal-products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        medicinalProductsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/medicinal-products/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Лекарственный препарат.
         * @param {PatchedMedicinalProduct} [patchedMedicinalProduct] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        medicinalProductsPartialUpdate: async (id: number, patchedMedicinalProduct?: PatchedMedicinalProduct, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('medicinalProductsPartialUpdate', 'id', id)
            const localVarPath = `/api/medicinal-products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedMedicinalProduct, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Лекарственный препарат.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        medicinalProductsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('medicinalProductsRetrieve', 'id', id)
            const localVarPath = `/api/medicinal-products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Лекарственный препарат.
         * @param {MedicinalProduct} medicinalProduct 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        medicinalProductsUpdate: async (id: number, medicinalProduct: MedicinalProduct, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('medicinalProductsUpdate', 'id', id)
            // verify required parameter 'medicinalProduct' is not null or undefined
            assertParamExists('medicinalProductsUpdate', 'medicinalProduct', medicinalProduct)
            const localVarPath = `/api/medicinal-products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(medicinalProduct, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MedicinalProductsApi - functional programming interface
 * @export
 */
export const MedicinalProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MedicinalProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {MedicinalProduct} medicinalProduct 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async medicinalProductsCreate(medicinalProduct: MedicinalProduct, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MedicinalProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.medicinalProductsCreate(medicinalProduct, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MedicinalProductsApi.medicinalProductsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Лекарственный препарат.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async medicinalProductsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.medicinalProductsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MedicinalProductsApi.medicinalProductsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async medicinalProductsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MedicinalProduct>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.medicinalProductsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MedicinalProductsApi.medicinalProductsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Лекарственный препарат.
         * @param {PatchedMedicinalProduct} [patchedMedicinalProduct] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async medicinalProductsPartialUpdate(id: number, patchedMedicinalProduct?: PatchedMedicinalProduct, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MedicinalProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.medicinalProductsPartialUpdate(id, patchedMedicinalProduct, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MedicinalProductsApi.medicinalProductsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Лекарственный препарат.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async medicinalProductsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MedicinalProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.medicinalProductsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MedicinalProductsApi.medicinalProductsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Лекарственный препарат.
         * @param {MedicinalProduct} medicinalProduct 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async medicinalProductsUpdate(id: number, medicinalProduct: MedicinalProduct, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MedicinalProduct>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.medicinalProductsUpdate(id, medicinalProduct, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MedicinalProductsApi.medicinalProductsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MedicinalProductsApi - factory interface
 * @export
 */
export const MedicinalProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MedicinalProductsApiFp(configuration)
    return {
        /**
         * 
         * @param {MedicinalProduct} medicinalProduct 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        medicinalProductsCreate(medicinalProduct: MedicinalProduct, options?: RawAxiosRequestConfig): AxiosPromise<MedicinalProduct> {
            return localVarFp.medicinalProductsCreate(medicinalProduct, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Лекарственный препарат.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        medicinalProductsDestroy(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.medicinalProductsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        medicinalProductsList(options?: RawAxiosRequestConfig): AxiosPromise<Array<MedicinalProduct>> {
            return localVarFp.medicinalProductsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Лекарственный препарат.
         * @param {PatchedMedicinalProduct} [patchedMedicinalProduct] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        medicinalProductsPartialUpdate(id: number, patchedMedicinalProduct?: PatchedMedicinalProduct, options?: RawAxiosRequestConfig): AxiosPromise<MedicinalProduct> {
            return localVarFp.medicinalProductsPartialUpdate(id, patchedMedicinalProduct, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Лекарственный препарат.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        medicinalProductsRetrieve(id: number, options?: RawAxiosRequestConfig): AxiosPromise<MedicinalProduct> {
            return localVarFp.medicinalProductsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Лекарственный препарат.
         * @param {MedicinalProduct} medicinalProduct 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        medicinalProductsUpdate(id: number, medicinalProduct: MedicinalProduct, options?: RawAxiosRequestConfig): AxiosPromise<MedicinalProduct> {
            return localVarFp.medicinalProductsUpdate(id, medicinalProduct, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MedicinalProductsApi - object-oriented interface
 * @export
 * @class MedicinalProductsApi
 * @extends {BaseAPI}
 */
export class MedicinalProductsApi extends BaseAPI {
    /**
     * 
     * @param {MedicinalProduct} medicinalProduct 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MedicinalProductsApi
     */
    public medicinalProductsCreate(medicinalProduct: MedicinalProduct, options?: RawAxiosRequestConfig) {
        return MedicinalProductsApiFp(this.configuration).medicinalProductsCreate(medicinalProduct, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Лекарственный препарат.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MedicinalProductsApi
     */
    public medicinalProductsDestroy(id: number, options?: RawAxiosRequestConfig) {
        return MedicinalProductsApiFp(this.configuration).medicinalProductsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MedicinalProductsApi
     */
    public medicinalProductsList(options?: RawAxiosRequestConfig) {
        return MedicinalProductsApiFp(this.configuration).medicinalProductsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Лекарственный препарат.
     * @param {PatchedMedicinalProduct} [patchedMedicinalProduct] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MedicinalProductsApi
     */
    public medicinalProductsPartialUpdate(id: number, patchedMedicinalProduct?: PatchedMedicinalProduct, options?: RawAxiosRequestConfig) {
        return MedicinalProductsApiFp(this.configuration).medicinalProductsPartialUpdate(id, patchedMedicinalProduct, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Лекарственный препарат.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MedicinalProductsApi
     */
    public medicinalProductsRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return MedicinalProductsApiFp(this.configuration).medicinalProductsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Лекарственный препарат.
     * @param {MedicinalProduct} medicinalProduct 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MedicinalProductsApi
     */
    public medicinalProductsUpdate(id: number, medicinalProduct: MedicinalProduct, options?: RawAxiosRequestConfig) {
        return MedicinalProductsApiFp(this.configuration).medicinalProductsUpdate(id, medicinalProduct, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ObligationsApi - axios parameter creator
 * @export
 */
export const ObligationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Obligation} obligation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obligationsCreate: async (obligation: Obligation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'obligation' is not null or undefined
            assertParamExists('obligationsCreate', 'obligation', obligation)
            const localVarPath = `/api/obligations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(obligation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Обязательство.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obligationsDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('obligationsDestroy', 'id', id)
            const localVarPath = `/api/obligations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [descriptionIcontains] 
         * @param {number} [pva] 
         * @param {string} [responsibilityTypeTitleIexact] 
         * @param {string} [titleIcontains] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obligationsList: async (descriptionIcontains?: string, pva?: number, responsibilityTypeTitleIexact?: string, titleIcontains?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/obligations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (descriptionIcontains !== undefined) {
                localVarQueryParameter['description__icontains'] = descriptionIcontains;
            }

            if (pva !== undefined) {
                localVarQueryParameter['pva'] = pva;
            }

            if (responsibilityTypeTitleIexact !== undefined) {
                localVarQueryParameter['responsibility_type__title__iexact'] = responsibilityTypeTitleIexact;
            }

            if (titleIcontains !== undefined) {
                localVarQueryParameter['title__icontains'] = titleIcontains;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Обязательство.
         * @param {PatchedObligation} [patchedObligation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obligationsPartialUpdate: async (id: number, patchedObligation?: PatchedObligation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('obligationsPartialUpdate', 'id', id)
            const localVarPath = `/api/obligations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedObligation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Обязательство.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obligationsRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('obligationsRetrieve', 'id', id)
            const localVarPath = `/api/obligations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Обязательство.
         * @param {Obligation} obligation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obligationsUpdate: async (id: number, obligation: Obligation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('obligationsUpdate', 'id', id)
            // verify required parameter 'obligation' is not null or undefined
            assertParamExists('obligationsUpdate', 'obligation', obligation)
            const localVarPath = `/api/obligations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(obligation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pvasObligationsList: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pvasObligationsList', 'id', id)
            const localVarPath = `/api/pvas/{id}/obligations/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObligationsApi - functional programming interface
 * @export
 */
export const ObligationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ObligationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Obligation} obligation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obligationsCreate(obligation: Obligation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Obligation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obligationsCreate(obligation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObligationsApi.obligationsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Обязательство.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obligationsDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obligationsDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObligationsApi.obligationsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [descriptionIcontains] 
         * @param {number} [pva] 
         * @param {string} [responsibilityTypeTitleIexact] 
         * @param {string} [titleIcontains] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obligationsList(descriptionIcontains?: string, pva?: number, responsibilityTypeTitleIexact?: string, titleIcontains?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Obligation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obligationsList(descriptionIcontains, pva, responsibilityTypeTitleIexact, titleIcontains, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObligationsApi.obligationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Обязательство.
         * @param {PatchedObligation} [patchedObligation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obligationsPartialUpdate(id: number, patchedObligation?: PatchedObligation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Obligation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obligationsPartialUpdate(id, patchedObligation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObligationsApi.obligationsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Обязательство.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obligationsRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Obligation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obligationsRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObligationsApi.obligationsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Обязательство.
         * @param {Obligation} obligation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obligationsUpdate(id: number, obligation: Obligation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Obligation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obligationsUpdate(id, obligation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObligationsApi.obligationsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pvasObligationsList(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Obligation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pvasObligationsList(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObligationsApi.pvasObligationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ObligationsApi - factory interface
 * @export
 */
export const ObligationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ObligationsApiFp(configuration)
    return {
        /**
         * 
         * @param {Obligation} obligation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obligationsCreate(obligation: Obligation, options?: RawAxiosRequestConfig): AxiosPromise<Obligation> {
            return localVarFp.obligationsCreate(obligation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Обязательство.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obligationsDestroy(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.obligationsDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [descriptionIcontains] 
         * @param {number} [pva] 
         * @param {string} [responsibilityTypeTitleIexact] 
         * @param {string} [titleIcontains] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obligationsList(descriptionIcontains?: string, pva?: number, responsibilityTypeTitleIexact?: string, titleIcontains?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Obligation>> {
            return localVarFp.obligationsList(descriptionIcontains, pva, responsibilityTypeTitleIexact, titleIcontains, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Обязательство.
         * @param {PatchedObligation} [patchedObligation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obligationsPartialUpdate(id: number, patchedObligation?: PatchedObligation, options?: RawAxiosRequestConfig): AxiosPromise<Obligation> {
            return localVarFp.obligationsPartialUpdate(id, patchedObligation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Обязательство.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obligationsRetrieve(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Obligation> {
            return localVarFp.obligationsRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Обязательство.
         * @param {Obligation} obligation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obligationsUpdate(id: number, obligation: Obligation, options?: RawAxiosRequestConfig): AxiosPromise<Obligation> {
            return localVarFp.obligationsUpdate(id, obligation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pvasObligationsList(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Obligation>> {
            return localVarFp.pvasObligationsList(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ObligationsApi - object-oriented interface
 * @export
 * @class ObligationsApi
 * @extends {BaseAPI}
 */
export class ObligationsApi extends BaseAPI {
    /**
     * 
     * @param {Obligation} obligation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObligationsApi
     */
    public obligationsCreate(obligation: Obligation, options?: RawAxiosRequestConfig) {
        return ObligationsApiFp(this.configuration).obligationsCreate(obligation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Обязательство.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObligationsApi
     */
    public obligationsDestroy(id: number, options?: RawAxiosRequestConfig) {
        return ObligationsApiFp(this.configuration).obligationsDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [descriptionIcontains] 
     * @param {number} [pva] 
     * @param {string} [responsibilityTypeTitleIexact] 
     * @param {string} [titleIcontains] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObligationsApi
     */
    public obligationsList(descriptionIcontains?: string, pva?: number, responsibilityTypeTitleIexact?: string, titleIcontains?: string, options?: RawAxiosRequestConfig) {
        return ObligationsApiFp(this.configuration).obligationsList(descriptionIcontains, pva, responsibilityTypeTitleIexact, titleIcontains, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Обязательство.
     * @param {PatchedObligation} [patchedObligation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObligationsApi
     */
    public obligationsPartialUpdate(id: number, patchedObligation?: PatchedObligation, options?: RawAxiosRequestConfig) {
        return ObligationsApiFp(this.configuration).obligationsPartialUpdate(id, patchedObligation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Обязательство.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObligationsApi
     */
    public obligationsRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return ObligationsApiFp(this.configuration).obligationsRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Обязательство.
     * @param {Obligation} obligation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObligationsApi
     */
    public obligationsUpdate(id: number, obligation: Obligation, options?: RawAxiosRequestConfig) {
        return ObligationsApiFp(this.configuration).obligationsUpdate(id, obligation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObligationsApi
     */
    public pvasObligationsList(id: number, options?: RawAxiosRequestConfig) {
        return ObligationsApiFp(this.configuration).pvasObligationsList(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PvasApi - axios parameter creator
 * @export
 */
export const PvasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PVA} pVA 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pvasCreate: async (pVA: PVA, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pVA' is not null or undefined
            assertParamExists('pvasCreate', 'pVA', pVA)
            const localVarPath = `/api/pvas/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pVA, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Договор.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pvasDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pvasDestroy', 'id', id)
            const localVarPath = `/api/pvas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [medicinalProductsTitleIcontains] 
         * @param {string} [requisitesIcontains] 
         * @param {PvasListStatusEnum} [status] * &#x60;PLANNED&#x60; - Планируемый * &#x60;ACTIVE&#x60; - Заключен * &#x60;ENDING&#x60; - Завершающийся * &#x60;COMPLETED&#x60; - Завершен
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pvasList: async (medicinalProductsTitleIcontains?: string, requisitesIcontains?: string, status?: PvasListStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/pvas/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (medicinalProductsTitleIcontains !== undefined) {
                localVarQueryParameter['medicinal_products__title__icontains'] = medicinalProductsTitleIcontains;
            }

            if (requisitesIcontains !== undefined) {
                localVarQueryParameter['requisites__icontains'] = requisitesIcontains;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Договор.
         * @param {PatchedPVA} [patchedPVA] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pvasPartialUpdate: async (id: number, patchedPVA?: PatchedPVA, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pvasPartialUpdate', 'id', id)
            const localVarPath = `/api/pvas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPVA, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Договор.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pvasRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pvasRetrieve', 'id', id)
            const localVarPath = `/api/pvas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Договор.
         * @param {PVA} pVA 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pvasUpdate: async (id: number, pVA: PVA, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pvasUpdate', 'id', id)
            // verify required parameter 'pVA' is not null or undefined
            assertParamExists('pvasUpdate', 'pVA', pVA)
            const localVarPath = `/api/pvas/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pVA, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PvasApi - functional programming interface
 * @export
 */
export const PvasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PvasApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PVA} pVA 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pvasCreate(pVA: PVA, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PVA>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pvasCreate(pVA, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PvasApi.pvasCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Договор.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pvasDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pvasDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PvasApi.pvasDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [medicinalProductsTitleIcontains] 
         * @param {string} [requisitesIcontains] 
         * @param {PvasListStatusEnum} [status] * &#x60;PLANNED&#x60; - Планируемый * &#x60;ACTIVE&#x60; - Заключен * &#x60;ENDING&#x60; - Завершающийся * &#x60;COMPLETED&#x60; - Завершен
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pvasList(medicinalProductsTitleIcontains?: string, requisitesIcontains?: string, status?: PvasListStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PVA>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pvasList(medicinalProductsTitleIcontains, requisitesIcontains, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PvasApi.pvasList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Договор.
         * @param {PatchedPVA} [patchedPVA] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pvasPartialUpdate(id: number, patchedPVA?: PatchedPVA, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PVA>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pvasPartialUpdate(id, patchedPVA, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PvasApi.pvasPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Договор.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pvasRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PVA>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pvasRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PvasApi.pvasRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Договор.
         * @param {PVA} pVA 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pvasUpdate(id: number, pVA: PVA, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PVA>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pvasUpdate(id, pVA, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PvasApi.pvasUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PvasApi - factory interface
 * @export
 */
export const PvasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PvasApiFp(configuration)
    return {
        /**
         * 
         * @param {PVA} pVA 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pvasCreate(pVA: PVA, options?: RawAxiosRequestConfig): AxiosPromise<PVA> {
            return localVarFp.pvasCreate(pVA, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Договор.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pvasDestroy(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pvasDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [medicinalProductsTitleIcontains] 
         * @param {string} [requisitesIcontains] 
         * @param {PvasListStatusEnum} [status] * &#x60;PLANNED&#x60; - Планируемый * &#x60;ACTIVE&#x60; - Заключен * &#x60;ENDING&#x60; - Завершающийся * &#x60;COMPLETED&#x60; - Завершен
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pvasList(medicinalProductsTitleIcontains?: string, requisitesIcontains?: string, status?: PvasListStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<PVA>> {
            return localVarFp.pvasList(medicinalProductsTitleIcontains, requisitesIcontains, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Договор.
         * @param {PatchedPVA} [patchedPVA] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pvasPartialUpdate(id: number, patchedPVA?: PatchedPVA, options?: RawAxiosRequestConfig): AxiosPromise<PVA> {
            return localVarFp.pvasPartialUpdate(id, patchedPVA, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Договор.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pvasRetrieve(id: number, options?: RawAxiosRequestConfig): AxiosPromise<PVA> {
            return localVarFp.pvasRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Договор.
         * @param {PVA} pVA 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pvasUpdate(id: number, pVA: PVA, options?: RawAxiosRequestConfig): AxiosPromise<PVA> {
            return localVarFp.pvasUpdate(id, pVA, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PvasApi - object-oriented interface
 * @export
 * @class PvasApi
 * @extends {BaseAPI}
 */
export class PvasApi extends BaseAPI {
    /**
     * 
     * @param {PVA} pVA 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PvasApi
     */
    public pvasCreate(pVA: PVA, options?: RawAxiosRequestConfig) {
        return PvasApiFp(this.configuration).pvasCreate(pVA, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Договор.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PvasApi
     */
    public pvasDestroy(id: number, options?: RawAxiosRequestConfig) {
        return PvasApiFp(this.configuration).pvasDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [medicinalProductsTitleIcontains] 
     * @param {string} [requisitesIcontains] 
     * @param {PvasListStatusEnum} [status] * &#x60;PLANNED&#x60; - Планируемый * &#x60;ACTIVE&#x60; - Заключен * &#x60;ENDING&#x60; - Завершающийся * &#x60;COMPLETED&#x60; - Завершен
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PvasApi
     */
    public pvasList(medicinalProductsTitleIcontains?: string, requisitesIcontains?: string, status?: PvasListStatusEnum, options?: RawAxiosRequestConfig) {
        return PvasApiFp(this.configuration).pvasList(medicinalProductsTitleIcontains, requisitesIcontains, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Договор.
     * @param {PatchedPVA} [patchedPVA] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PvasApi
     */
    public pvasPartialUpdate(id: number, patchedPVA?: PatchedPVA, options?: RawAxiosRequestConfig) {
        return PvasApiFp(this.configuration).pvasPartialUpdate(id, patchedPVA, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Договор.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PvasApi
     */
    public pvasRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return PvasApiFp(this.configuration).pvasRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Договор.
     * @param {PVA} pVA 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PvasApi
     */
    public pvasUpdate(id: number, pVA: PVA, options?: RawAxiosRequestConfig) {
        return PvasApiFp(this.configuration).pvasUpdate(id, pVA, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const PvasListStatusEnum = {
    Active: 'ACTIVE',
    Completed: 'COMPLETED',
    Ending: 'ENDING',
    Planned: 'PLANNED'
} as const;
export type PvasListStatusEnum = typeof PvasListStatusEnum[keyof typeof PvasListStatusEnum];


/**
 * ResponsibilityTypesApi - axios parameter creator
 * @export
 */
export const ResponsibilityTypesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ResponsibilityType} responsibilityType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        responsibilityTypesCreate: async (responsibilityType: ResponsibilityType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'responsibilityType' is not null or undefined
            assertParamExists('responsibilityTypesCreate', 'responsibilityType', responsibilityType)
            const localVarPath = `/api/responsibility-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(responsibilityType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Тип обязательства.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        responsibilityTypesDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('responsibilityTypesDestroy', 'id', id)
            const localVarPath = `/api/responsibility-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        responsibilityTypesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/responsibility-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Тип обязательства.
         * @param {PatchedResponsibilityType} [patchedResponsibilityType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        responsibilityTypesPartialUpdate: async (id: number, patchedResponsibilityType?: PatchedResponsibilityType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('responsibilityTypesPartialUpdate', 'id', id)
            const localVarPath = `/api/responsibility-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedResponsibilityType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Тип обязательства.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        responsibilityTypesRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('responsibilityTypesRetrieve', 'id', id)
            const localVarPath = `/api/responsibility-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Тип обязательства.
         * @param {ResponsibilityType} responsibilityType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        responsibilityTypesUpdate: async (id: number, responsibilityType: ResponsibilityType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('responsibilityTypesUpdate', 'id', id)
            // verify required parameter 'responsibilityType' is not null or undefined
            assertParamExists('responsibilityTypesUpdate', 'responsibilityType', responsibilityType)
            const localVarPath = `/api/responsibility-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(responsibilityType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResponsibilityTypesApi - functional programming interface
 * @export
 */
export const ResponsibilityTypesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResponsibilityTypesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ResponsibilityType} responsibilityType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async responsibilityTypesCreate(responsibilityType: ResponsibilityType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponsibilityType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.responsibilityTypesCreate(responsibilityType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResponsibilityTypesApi.responsibilityTypesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Тип обязательства.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async responsibilityTypesDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.responsibilityTypesDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResponsibilityTypesApi.responsibilityTypesDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async responsibilityTypesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResponsibilityType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.responsibilityTypesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResponsibilityTypesApi.responsibilityTypesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Тип обязательства.
         * @param {PatchedResponsibilityType} [patchedResponsibilityType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async responsibilityTypesPartialUpdate(id: number, patchedResponsibilityType?: PatchedResponsibilityType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponsibilityType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.responsibilityTypesPartialUpdate(id, patchedResponsibilityType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResponsibilityTypesApi.responsibilityTypesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Тип обязательства.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async responsibilityTypesRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponsibilityType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.responsibilityTypesRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResponsibilityTypesApi.responsibilityTypesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Тип обязательства.
         * @param {ResponsibilityType} responsibilityType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async responsibilityTypesUpdate(id: number, responsibilityType: ResponsibilityType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponsibilityType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.responsibilityTypesUpdate(id, responsibilityType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResponsibilityTypesApi.responsibilityTypesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResponsibilityTypesApi - factory interface
 * @export
 */
export const ResponsibilityTypesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResponsibilityTypesApiFp(configuration)
    return {
        /**
         * 
         * @param {ResponsibilityType} responsibilityType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        responsibilityTypesCreate(responsibilityType: ResponsibilityType, options?: RawAxiosRequestConfig): AxiosPromise<ResponsibilityType> {
            return localVarFp.responsibilityTypesCreate(responsibilityType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Тип обязательства.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        responsibilityTypesDestroy(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.responsibilityTypesDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        responsibilityTypesList(options?: RawAxiosRequestConfig): AxiosPromise<Array<ResponsibilityType>> {
            return localVarFp.responsibilityTypesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Тип обязательства.
         * @param {PatchedResponsibilityType} [patchedResponsibilityType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        responsibilityTypesPartialUpdate(id: number, patchedResponsibilityType?: PatchedResponsibilityType, options?: RawAxiosRequestConfig): AxiosPromise<ResponsibilityType> {
            return localVarFp.responsibilityTypesPartialUpdate(id, patchedResponsibilityType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Тип обязательства.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        responsibilityTypesRetrieve(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ResponsibilityType> {
            return localVarFp.responsibilityTypesRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Тип обязательства.
         * @param {ResponsibilityType} responsibilityType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        responsibilityTypesUpdate(id: number, responsibilityType: ResponsibilityType, options?: RawAxiosRequestConfig): AxiosPromise<ResponsibilityType> {
            return localVarFp.responsibilityTypesUpdate(id, responsibilityType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResponsibilityTypesApi - object-oriented interface
 * @export
 * @class ResponsibilityTypesApi
 * @extends {BaseAPI}
 */
export class ResponsibilityTypesApi extends BaseAPI {
    /**
     * 
     * @param {ResponsibilityType} responsibilityType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResponsibilityTypesApi
     */
    public responsibilityTypesCreate(responsibilityType: ResponsibilityType, options?: RawAxiosRequestConfig) {
        return ResponsibilityTypesApiFp(this.configuration).responsibilityTypesCreate(responsibilityType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Тип обязательства.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResponsibilityTypesApi
     */
    public responsibilityTypesDestroy(id: number, options?: RawAxiosRequestConfig) {
        return ResponsibilityTypesApiFp(this.configuration).responsibilityTypesDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResponsibilityTypesApi
     */
    public responsibilityTypesList(options?: RawAxiosRequestConfig) {
        return ResponsibilityTypesApiFp(this.configuration).responsibilityTypesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Тип обязательства.
     * @param {PatchedResponsibilityType} [patchedResponsibilityType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResponsibilityTypesApi
     */
    public responsibilityTypesPartialUpdate(id: number, patchedResponsibilityType?: PatchedResponsibilityType, options?: RawAxiosRequestConfig) {
        return ResponsibilityTypesApiFp(this.configuration).responsibilityTypesPartialUpdate(id, patchedResponsibilityType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Тип обязательства.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResponsibilityTypesApi
     */
    public responsibilityTypesRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return ResponsibilityTypesApiFp(this.configuration).responsibilityTypesRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Тип обязательства.
     * @param {ResponsibilityType} responsibilityType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResponsibilityTypesApi
     */
    public responsibilityTypesUpdate(id: number, responsibilityType: ResponsibilityType, options?: RawAxiosRequestConfig) {
        return ResponsibilityTypesApiFp(this.configuration).responsibilityTypesUpdate(id, responsibilityType, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obligationsTasksList: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('obligationsTasksList', 'id', id)
            const localVarPath = `/api/obligations/{id}/tasks/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Задача.
         * @param {TaskStatus} taskStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksChangeStatusCreate: async (id: number, taskStatus: TaskStatus, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksChangeStatusCreate', 'id', id)
            // verify required parameter 'taskStatus' is not null or undefined
            assertParamExists('tasksChangeStatusCreate', 'taskStatus', taskStatus)
            const localVarPath = `/api/tasks/{id}/change-status/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taskStatus, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksChangelogList: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksChangelogList', 'id', id)
            const localVarPath = `/api/tasks/{id}/changelog/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCommentsCreate: async (id: number, comment: Comment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksCommentsCreate', 'id', id)
            // verify required parameter 'comment' is not null or undefined
            assertParamExists('tasksCommentsCreate', 'comment', comment)
            const localVarPath = `/api/tasks/{id}/comments/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(comment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCommentsList: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksCommentsList', 'id', id)
            const localVarPath = `/api/tasks/{id}/comments/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [assignedTo] 
         * @param {string} [assignedToLastNameIcontains] 
         * @param {string} [assignedToUsernameIexact] 
         * @param {string} [createdByLastNameIcontains] 
         * @param {string} [createdByUsername] 
         * @param {string} [deadlineGte] 
         * @param {string} [deadlineLte] 
         * @param {string} [descriptionIcontains] 
         * @param {number} [obligation] 
         * @param {string} [obligationResponsibilityTypeTitleIexact] 
         * @param {TasksCompletedListStatusEnum} [status] * &#x60;NOT_STARTED&#x60; - Не начата * &#x60;IN_PROGRESS&#x60; - В работе * &#x60;COMPLETED&#x60; - Завершена * &#x60;HIDDEN&#x60; - Скрыта
         * @param {string} [titleIcontains] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCompletedList: async (assignedTo?: number, assignedToLastNameIcontains?: string, assignedToUsernameIexact?: string, createdByLastNameIcontains?: string, createdByUsername?: string, deadlineGte?: string, deadlineLte?: string, descriptionIcontains?: string, obligation?: number, obligationResponsibilityTypeTitleIexact?: string, status?: TasksCompletedListStatusEnum, titleIcontains?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/completed/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (assignedTo !== undefined) {
                localVarQueryParameter['assigned_to'] = assignedTo;
            }

            if (assignedToLastNameIcontains !== undefined) {
                localVarQueryParameter['assigned_to__last_name__icontains'] = assignedToLastNameIcontains;
            }

            if (assignedToUsernameIexact !== undefined) {
                localVarQueryParameter['assigned_to__username__iexact'] = assignedToUsernameIexact;
            }

            if (createdByLastNameIcontains !== undefined) {
                localVarQueryParameter['created_by__last_name__icontains'] = createdByLastNameIcontains;
            }

            if (createdByUsername !== undefined) {
                localVarQueryParameter['created_by__username'] = createdByUsername;
            }

            if (deadlineGte !== undefined) {
                localVarQueryParameter['deadline__gte'] = (deadlineGte as any instanceof Date) ?
                    (deadlineGte as any).toISOString() :
                    deadlineGte;
            }

            if (deadlineLte !== undefined) {
                localVarQueryParameter['deadline__lte'] = (deadlineLte as any instanceof Date) ?
                    (deadlineLte as any).toISOString() :
                    deadlineLte;
            }

            if (descriptionIcontains !== undefined) {
                localVarQueryParameter['description__icontains'] = descriptionIcontains;
            }

            if (obligation !== undefined) {
                localVarQueryParameter['obligation'] = obligation;
            }

            if (obligationResponsibilityTypeTitleIexact !== undefined) {
                localVarQueryParameter['obligation__responsibility_type__title__iexact'] = obligationResponsibilityTypeTitleIexact;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (titleIcontains !== undefined) {
                localVarQueryParameter['title__icontains'] = titleIcontains;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Task} task 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreate: async (task: Task, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'task' is not null or undefined
            assertParamExists('tasksCreate', 'task', task)
            const localVarPath = `/api/tasks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(task, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Задача.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksDestroy', 'id', id)
            const localVarPath = `/api/tasks/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [assignedTo] 
         * @param {string} [assignedToLastNameIcontains] 
         * @param {string} [assignedToUsernameIexact] 
         * @param {string} [createdByLastNameIcontains] 
         * @param {string} [createdByUsername] 
         * @param {string} [deadlineGte] 
         * @param {string} [deadlineLte] 
         * @param {string} [descriptionIcontains] 
         * @param {number} [obligation] 
         * @param {string} [obligationResponsibilityTypeTitleIexact] 
         * @param {TasksListStatusEnum} [status] * &#x60;NOT_STARTED&#x60; - Не начата * &#x60;IN_PROGRESS&#x60; - В работе * &#x60;COMPLETED&#x60; - Завершена * &#x60;HIDDEN&#x60; - Скрыта
         * @param {string} [titleIcontains] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksList: async (assignedTo?: number, assignedToLastNameIcontains?: string, assignedToUsernameIexact?: string, createdByLastNameIcontains?: string, createdByUsername?: string, deadlineGte?: string, deadlineLte?: string, descriptionIcontains?: string, obligation?: number, obligationResponsibilityTypeTitleIexact?: string, status?: TasksListStatusEnum, titleIcontains?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (assignedTo !== undefined) {
                localVarQueryParameter['assigned_to'] = assignedTo;
            }

            if (assignedToLastNameIcontains !== undefined) {
                localVarQueryParameter['assigned_to__last_name__icontains'] = assignedToLastNameIcontains;
            }

            if (assignedToUsernameIexact !== undefined) {
                localVarQueryParameter['assigned_to__username__iexact'] = assignedToUsernameIexact;
            }

            if (createdByLastNameIcontains !== undefined) {
                localVarQueryParameter['created_by__last_name__icontains'] = createdByLastNameIcontains;
            }

            if (createdByUsername !== undefined) {
                localVarQueryParameter['created_by__username'] = createdByUsername;
            }

            if (deadlineGte !== undefined) {
                localVarQueryParameter['deadline__gte'] = (deadlineGte as any instanceof Date) ?
                    (deadlineGte as any).toISOString() :
                    deadlineGte;
            }

            if (deadlineLte !== undefined) {
                localVarQueryParameter['deadline__lte'] = (deadlineLte as any instanceof Date) ?
                    (deadlineLte as any).toISOString() :
                    deadlineLte;
            }

            if (descriptionIcontains !== undefined) {
                localVarQueryParameter['description__icontains'] = descriptionIcontains;
            }

            if (obligation !== undefined) {
                localVarQueryParameter['obligation'] = obligation;
            }

            if (obligationResponsibilityTypeTitleIexact !== undefined) {
                localVarQueryParameter['obligation__responsibility_type__title__iexact'] = obligationResponsibilityTypeTitleIexact;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (titleIcontains !== undefined) {
                localVarQueryParameter['title__icontains'] = titleIcontains;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [assignedTo] 
         * @param {string} [assignedToLastNameIcontains] 
         * @param {string} [assignedToUsernameIexact] 
         * @param {string} [createdByLastNameIcontains] 
         * @param {string} [createdByUsername] 
         * @param {string} [deadlineGte] 
         * @param {string} [deadlineLte] 
         * @param {string} [descriptionIcontains] 
         * @param {number} [obligation] 
         * @param {string} [obligationResponsibilityTypeTitleIexact] 
         * @param {TasksMyCompletedListStatusEnum} [status] * &#x60;NOT_STARTED&#x60; - Не начата * &#x60;IN_PROGRESS&#x60; - В работе * &#x60;COMPLETED&#x60; - Завершена * &#x60;HIDDEN&#x60; - Скрыта
         * @param {string} [titleIcontains] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksMyCompletedList: async (assignedTo?: number, assignedToLastNameIcontains?: string, assignedToUsernameIexact?: string, createdByLastNameIcontains?: string, createdByUsername?: string, deadlineGte?: string, deadlineLte?: string, descriptionIcontains?: string, obligation?: number, obligationResponsibilityTypeTitleIexact?: string, status?: TasksMyCompletedListStatusEnum, titleIcontains?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/my/completed/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (assignedTo !== undefined) {
                localVarQueryParameter['assigned_to'] = assignedTo;
            }

            if (assignedToLastNameIcontains !== undefined) {
                localVarQueryParameter['assigned_to__last_name__icontains'] = assignedToLastNameIcontains;
            }

            if (assignedToUsernameIexact !== undefined) {
                localVarQueryParameter['assigned_to__username__iexact'] = assignedToUsernameIexact;
            }

            if (createdByLastNameIcontains !== undefined) {
                localVarQueryParameter['created_by__last_name__icontains'] = createdByLastNameIcontains;
            }

            if (createdByUsername !== undefined) {
                localVarQueryParameter['created_by__username'] = createdByUsername;
            }

            if (deadlineGte !== undefined) {
                localVarQueryParameter['deadline__gte'] = (deadlineGte as any instanceof Date) ?
                    (deadlineGte as any).toISOString() :
                    deadlineGte;
            }

            if (deadlineLte !== undefined) {
                localVarQueryParameter['deadline__lte'] = (deadlineLte as any instanceof Date) ?
                    (deadlineLte as any).toISOString() :
                    deadlineLte;
            }

            if (descriptionIcontains !== undefined) {
                localVarQueryParameter['description__icontains'] = descriptionIcontains;
            }

            if (obligation !== undefined) {
                localVarQueryParameter['obligation'] = obligation;
            }

            if (obligationResponsibilityTypeTitleIexact !== undefined) {
                localVarQueryParameter['obligation__responsibility_type__title__iexact'] = obligationResponsibilityTypeTitleIexact;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (titleIcontains !== undefined) {
                localVarQueryParameter['title__icontains'] = titleIcontains;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [assignedTo] 
         * @param {string} [assignedToLastNameIcontains] 
         * @param {string} [assignedToUsernameIexact] 
         * @param {string} [createdByLastNameIcontains] 
         * @param {string} [createdByUsername] 
         * @param {string} [deadlineGte] 
         * @param {string} [deadlineLte] 
         * @param {string} [descriptionIcontains] 
         * @param {number} [obligation] 
         * @param {string} [obligationResponsibilityTypeTitleIexact] 
         * @param {TasksMyListStatusEnum} [status] * &#x60;NOT_STARTED&#x60; - Не начата * &#x60;IN_PROGRESS&#x60; - В работе * &#x60;COMPLETED&#x60; - Завершена * &#x60;HIDDEN&#x60; - Скрыта
         * @param {string} [titleIcontains] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksMyList: async (assignedTo?: number, assignedToLastNameIcontains?: string, assignedToUsernameIexact?: string, createdByLastNameIcontains?: string, createdByUsername?: string, deadlineGte?: string, deadlineLte?: string, descriptionIcontains?: string, obligation?: number, obligationResponsibilityTypeTitleIexact?: string, status?: TasksMyListStatusEnum, titleIcontains?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tasks/my/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (assignedTo !== undefined) {
                localVarQueryParameter['assigned_to'] = assignedTo;
            }

            if (assignedToLastNameIcontains !== undefined) {
                localVarQueryParameter['assigned_to__last_name__icontains'] = assignedToLastNameIcontains;
            }

            if (assignedToUsernameIexact !== undefined) {
                localVarQueryParameter['assigned_to__username__iexact'] = assignedToUsernameIexact;
            }

            if (createdByLastNameIcontains !== undefined) {
                localVarQueryParameter['created_by__last_name__icontains'] = createdByLastNameIcontains;
            }

            if (createdByUsername !== undefined) {
                localVarQueryParameter['created_by__username'] = createdByUsername;
            }

            if (deadlineGte !== undefined) {
                localVarQueryParameter['deadline__gte'] = (deadlineGte as any instanceof Date) ?
                    (deadlineGte as any).toISOString() :
                    deadlineGte;
            }

            if (deadlineLte !== undefined) {
                localVarQueryParameter['deadline__lte'] = (deadlineLte as any instanceof Date) ?
                    (deadlineLte as any).toISOString() :
                    deadlineLte;
            }

            if (descriptionIcontains !== undefined) {
                localVarQueryParameter['description__icontains'] = descriptionIcontains;
            }

            if (obligation !== undefined) {
                localVarQueryParameter['obligation'] = obligation;
            }

            if (obligationResponsibilityTypeTitleIexact !== undefined) {
                localVarQueryParameter['obligation__responsibility_type__title__iexact'] = obligationResponsibilityTypeTitleIexact;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (titleIcontains !== undefined) {
                localVarQueryParameter['title__icontains'] = titleIcontains;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Задача.
         * @param {PatchedTask} [patchedTask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksPartialUpdate: async (id: number, patchedTask?: PatchedTask, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksPartialUpdate', 'id', id)
            const localVarPath = `/api/tasks/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedTask, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Задача.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksRetrieve', 'id', id)
            const localVarPath = `/api/tasks/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Задача.
         * @param {Task} task 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksUpdate: async (id: number, task: Task, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tasksUpdate', 'id', id)
            // verify required parameter 'task' is not null or undefined
            assertParamExists('tasksUpdate', 'task', task)
            const localVarPath = `/api/tasks/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(task, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async obligationsTasksList(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.obligationsTasksList(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.obligationsTasksList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Задача.
         * @param {TaskStatus} taskStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksChangeStatusCreate(id: number, taskStatus: TaskStatus, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksChangeStatusCreate(id, taskStatus, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksChangeStatusCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksChangelogList(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LogEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksChangelogList(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksChangelogList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksCommentsCreate(id: number, comment: Comment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksCommentsCreate(id, comment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksCommentsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksCommentsList(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Comment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksCommentsList(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksCommentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [assignedTo] 
         * @param {string} [assignedToLastNameIcontains] 
         * @param {string} [assignedToUsernameIexact] 
         * @param {string} [createdByLastNameIcontains] 
         * @param {string} [createdByUsername] 
         * @param {string} [deadlineGte] 
         * @param {string} [deadlineLte] 
         * @param {string} [descriptionIcontains] 
         * @param {number} [obligation] 
         * @param {string} [obligationResponsibilityTypeTitleIexact] 
         * @param {TasksCompletedListStatusEnum} [status] * &#x60;NOT_STARTED&#x60; - Не начата * &#x60;IN_PROGRESS&#x60; - В работе * &#x60;COMPLETED&#x60; - Завершена * &#x60;HIDDEN&#x60; - Скрыта
         * @param {string} [titleIcontains] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksCompletedList(assignedTo?: number, assignedToLastNameIcontains?: string, assignedToUsernameIexact?: string, createdByLastNameIcontains?: string, createdByUsername?: string, deadlineGte?: string, deadlineLte?: string, descriptionIcontains?: string, obligation?: number, obligationResponsibilityTypeTitleIexact?: string, status?: TasksCompletedListStatusEnum, titleIcontains?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksCompletedList(assignedTo, assignedToLastNameIcontains, assignedToUsernameIexact, createdByLastNameIcontains, createdByUsername, deadlineGte, deadlineLte, descriptionIcontains, obligation, obligationResponsibilityTypeTitleIexact, status, titleIcontains, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksCompletedList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Task} task 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksCreate(task: Task, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksCreate(task, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Задача.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [assignedTo] 
         * @param {string} [assignedToLastNameIcontains] 
         * @param {string} [assignedToUsernameIexact] 
         * @param {string} [createdByLastNameIcontains] 
         * @param {string} [createdByUsername] 
         * @param {string} [deadlineGte] 
         * @param {string} [deadlineLte] 
         * @param {string} [descriptionIcontains] 
         * @param {number} [obligation] 
         * @param {string} [obligationResponsibilityTypeTitleIexact] 
         * @param {TasksListStatusEnum} [status] * &#x60;NOT_STARTED&#x60; - Не начата * &#x60;IN_PROGRESS&#x60; - В работе * &#x60;COMPLETED&#x60; - Завершена * &#x60;HIDDEN&#x60; - Скрыта
         * @param {string} [titleIcontains] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksList(assignedTo?: number, assignedToLastNameIcontains?: string, assignedToUsernameIexact?: string, createdByLastNameIcontains?: string, createdByUsername?: string, deadlineGte?: string, deadlineLte?: string, descriptionIcontains?: string, obligation?: number, obligationResponsibilityTypeTitleIexact?: string, status?: TasksListStatusEnum, titleIcontains?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksList(assignedTo, assignedToLastNameIcontains, assignedToUsernameIexact, createdByLastNameIcontains, createdByUsername, deadlineGte, deadlineLte, descriptionIcontains, obligation, obligationResponsibilityTypeTitleIexact, status, titleIcontains, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [assignedTo] 
         * @param {string} [assignedToLastNameIcontains] 
         * @param {string} [assignedToUsernameIexact] 
         * @param {string} [createdByLastNameIcontains] 
         * @param {string} [createdByUsername] 
         * @param {string} [deadlineGte] 
         * @param {string} [deadlineLte] 
         * @param {string} [descriptionIcontains] 
         * @param {number} [obligation] 
         * @param {string} [obligationResponsibilityTypeTitleIexact] 
         * @param {TasksMyCompletedListStatusEnum} [status] * &#x60;NOT_STARTED&#x60; - Не начата * &#x60;IN_PROGRESS&#x60; - В работе * &#x60;COMPLETED&#x60; - Завершена * &#x60;HIDDEN&#x60; - Скрыта
         * @param {string} [titleIcontains] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksMyCompletedList(assignedTo?: number, assignedToLastNameIcontains?: string, assignedToUsernameIexact?: string, createdByLastNameIcontains?: string, createdByUsername?: string, deadlineGte?: string, deadlineLte?: string, descriptionIcontains?: string, obligation?: number, obligationResponsibilityTypeTitleIexact?: string, status?: TasksMyCompletedListStatusEnum, titleIcontains?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksMyCompletedList(assignedTo, assignedToLastNameIcontains, assignedToUsernameIexact, createdByLastNameIcontains, createdByUsername, deadlineGte, deadlineLte, descriptionIcontains, obligation, obligationResponsibilityTypeTitleIexact, status, titleIcontains, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksMyCompletedList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [assignedTo] 
         * @param {string} [assignedToLastNameIcontains] 
         * @param {string} [assignedToUsernameIexact] 
         * @param {string} [createdByLastNameIcontains] 
         * @param {string} [createdByUsername] 
         * @param {string} [deadlineGte] 
         * @param {string} [deadlineLte] 
         * @param {string} [descriptionIcontains] 
         * @param {number} [obligation] 
         * @param {string} [obligationResponsibilityTypeTitleIexact] 
         * @param {TasksMyListStatusEnum} [status] * &#x60;NOT_STARTED&#x60; - Не начата * &#x60;IN_PROGRESS&#x60; - В работе * &#x60;COMPLETED&#x60; - Завершена * &#x60;HIDDEN&#x60; - Скрыта
         * @param {string} [titleIcontains] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksMyList(assignedTo?: number, assignedToLastNameIcontains?: string, assignedToUsernameIexact?: string, createdByLastNameIcontains?: string, createdByUsername?: string, deadlineGte?: string, deadlineLte?: string, descriptionIcontains?: string, obligation?: number, obligationResponsibilityTypeTitleIexact?: string, status?: TasksMyListStatusEnum, titleIcontains?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksMyList(assignedTo, assignedToLastNameIcontains, assignedToUsernameIexact, createdByLastNameIcontains, createdByUsername, deadlineGte, deadlineLte, descriptionIcontains, obligation, obligationResponsibilityTypeTitleIexact, status, titleIcontains, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksMyList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Задача.
         * @param {PatchedTask} [patchedTask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksPartialUpdate(id: number, patchedTask?: PatchedTask, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksPartialUpdate(id, patchedTask, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Задача.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Задача.
         * @param {Task} task 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksUpdate(id: number, task: Task, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksUpdate(id, task, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.tasksUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        obligationsTasksList(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Task>> {
            return localVarFp.obligationsTasksList(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Задача.
         * @param {TaskStatus} taskStatus 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksChangeStatusCreate(id: number, taskStatus: TaskStatus, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tasksChangeStatusCreate(id, taskStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksChangelogList(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<LogEntry>> {
            return localVarFp.tasksChangelogList(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCommentsCreate(id: number, comment: Comment, options?: RawAxiosRequestConfig): AxiosPromise<Comment> {
            return localVarFp.tasksCommentsCreate(id, comment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCommentsList(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Comment>> {
            return localVarFp.tasksCommentsList(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [assignedTo] 
         * @param {string} [assignedToLastNameIcontains] 
         * @param {string} [assignedToUsernameIexact] 
         * @param {string} [createdByLastNameIcontains] 
         * @param {string} [createdByUsername] 
         * @param {string} [deadlineGte] 
         * @param {string} [deadlineLte] 
         * @param {string} [descriptionIcontains] 
         * @param {number} [obligation] 
         * @param {string} [obligationResponsibilityTypeTitleIexact] 
         * @param {TasksCompletedListStatusEnum} [status] * &#x60;NOT_STARTED&#x60; - Не начата * &#x60;IN_PROGRESS&#x60; - В работе * &#x60;COMPLETED&#x60; - Завершена * &#x60;HIDDEN&#x60; - Скрыта
         * @param {string} [titleIcontains] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCompletedList(assignedTo?: number, assignedToLastNameIcontains?: string, assignedToUsernameIexact?: string, createdByLastNameIcontains?: string, createdByUsername?: string, deadlineGte?: string, deadlineLte?: string, descriptionIcontains?: string, obligation?: number, obligationResponsibilityTypeTitleIexact?: string, status?: TasksCompletedListStatusEnum, titleIcontains?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Task>> {
            return localVarFp.tasksCompletedList(assignedTo, assignedToLastNameIcontains, assignedToUsernameIexact, createdByLastNameIcontains, createdByUsername, deadlineGte, deadlineLte, descriptionIcontains, obligation, obligationResponsibilityTypeTitleIexact, status, titleIcontains, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Task} task 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksCreate(task: Task, options?: RawAxiosRequestConfig): AxiosPromise<Task> {
            return localVarFp.tasksCreate(task, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Задача.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksDestroy(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.tasksDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [assignedTo] 
         * @param {string} [assignedToLastNameIcontains] 
         * @param {string} [assignedToUsernameIexact] 
         * @param {string} [createdByLastNameIcontains] 
         * @param {string} [createdByUsername] 
         * @param {string} [deadlineGte] 
         * @param {string} [deadlineLte] 
         * @param {string} [descriptionIcontains] 
         * @param {number} [obligation] 
         * @param {string} [obligationResponsibilityTypeTitleIexact] 
         * @param {TasksListStatusEnum} [status] * &#x60;NOT_STARTED&#x60; - Не начата * &#x60;IN_PROGRESS&#x60; - В работе * &#x60;COMPLETED&#x60; - Завершена * &#x60;HIDDEN&#x60; - Скрыта
         * @param {string} [titleIcontains] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksList(assignedTo?: number, assignedToLastNameIcontains?: string, assignedToUsernameIexact?: string, createdByLastNameIcontains?: string, createdByUsername?: string, deadlineGte?: string, deadlineLte?: string, descriptionIcontains?: string, obligation?: number, obligationResponsibilityTypeTitleIexact?: string, status?: TasksListStatusEnum, titleIcontains?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Task>> {
            return localVarFp.tasksList(assignedTo, assignedToLastNameIcontains, assignedToUsernameIexact, createdByLastNameIcontains, createdByUsername, deadlineGte, deadlineLte, descriptionIcontains, obligation, obligationResponsibilityTypeTitleIexact, status, titleIcontains, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [assignedTo] 
         * @param {string} [assignedToLastNameIcontains] 
         * @param {string} [assignedToUsernameIexact] 
         * @param {string} [createdByLastNameIcontains] 
         * @param {string} [createdByUsername] 
         * @param {string} [deadlineGte] 
         * @param {string} [deadlineLte] 
         * @param {string} [descriptionIcontains] 
         * @param {number} [obligation] 
         * @param {string} [obligationResponsibilityTypeTitleIexact] 
         * @param {TasksMyCompletedListStatusEnum} [status] * &#x60;NOT_STARTED&#x60; - Не начата * &#x60;IN_PROGRESS&#x60; - В работе * &#x60;COMPLETED&#x60; - Завершена * &#x60;HIDDEN&#x60; - Скрыта
         * @param {string} [titleIcontains] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksMyCompletedList(assignedTo?: number, assignedToLastNameIcontains?: string, assignedToUsernameIexact?: string, createdByLastNameIcontains?: string, createdByUsername?: string, deadlineGte?: string, deadlineLte?: string, descriptionIcontains?: string, obligation?: number, obligationResponsibilityTypeTitleIexact?: string, status?: TasksMyCompletedListStatusEnum, titleIcontains?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Task>> {
            return localVarFp.tasksMyCompletedList(assignedTo, assignedToLastNameIcontains, assignedToUsernameIexact, createdByLastNameIcontains, createdByUsername, deadlineGte, deadlineLte, descriptionIcontains, obligation, obligationResponsibilityTypeTitleIexact, status, titleIcontains, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [assignedTo] 
         * @param {string} [assignedToLastNameIcontains] 
         * @param {string} [assignedToUsernameIexact] 
         * @param {string} [createdByLastNameIcontains] 
         * @param {string} [createdByUsername] 
         * @param {string} [deadlineGte] 
         * @param {string} [deadlineLte] 
         * @param {string} [descriptionIcontains] 
         * @param {number} [obligation] 
         * @param {string} [obligationResponsibilityTypeTitleIexact] 
         * @param {TasksMyListStatusEnum} [status] * &#x60;NOT_STARTED&#x60; - Не начата * &#x60;IN_PROGRESS&#x60; - В работе * &#x60;COMPLETED&#x60; - Завершена * &#x60;HIDDEN&#x60; - Скрыта
         * @param {string} [titleIcontains] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksMyList(assignedTo?: number, assignedToLastNameIcontains?: string, assignedToUsernameIexact?: string, createdByLastNameIcontains?: string, createdByUsername?: string, deadlineGte?: string, deadlineLte?: string, descriptionIcontains?: string, obligation?: number, obligationResponsibilityTypeTitleIexact?: string, status?: TasksMyListStatusEnum, titleIcontains?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Task>> {
            return localVarFp.tasksMyList(assignedTo, assignedToLastNameIcontains, assignedToUsernameIexact, createdByLastNameIcontains, createdByUsername, deadlineGte, deadlineLte, descriptionIcontains, obligation, obligationResponsibilityTypeTitleIexact, status, titleIcontains, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Задача.
         * @param {PatchedTask} [patchedTask] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksPartialUpdate(id: number, patchedTask?: PatchedTask, options?: RawAxiosRequestConfig): AxiosPromise<Task> {
            return localVarFp.tasksPartialUpdate(id, patchedTask, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Задача.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksRetrieve(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Task> {
            return localVarFp.tasksRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Задача.
         * @param {Task} task 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksUpdate(id: number, task: Task, options?: RawAxiosRequestConfig): AxiosPromise<Task> {
            return localVarFp.tasksUpdate(id, task, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public obligationsTasksList(id: number, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).obligationsTasksList(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Задача.
     * @param {TaskStatus} taskStatus 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksChangeStatusCreate(id: number, taskStatus: TaskStatus, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksChangeStatusCreate(id, taskStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksChangelogList(id: number, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksChangelogList(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {Comment} comment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksCommentsCreate(id: number, comment: Comment, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksCommentsCreate(id, comment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksCommentsList(id: number, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksCommentsList(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [assignedTo] 
     * @param {string} [assignedToLastNameIcontains] 
     * @param {string} [assignedToUsernameIexact] 
     * @param {string} [createdByLastNameIcontains] 
     * @param {string} [createdByUsername] 
     * @param {string} [deadlineGte] 
     * @param {string} [deadlineLte] 
     * @param {string} [descriptionIcontains] 
     * @param {number} [obligation] 
     * @param {string} [obligationResponsibilityTypeTitleIexact] 
     * @param {TasksCompletedListStatusEnum} [status] * &#x60;NOT_STARTED&#x60; - Не начата * &#x60;IN_PROGRESS&#x60; - В работе * &#x60;COMPLETED&#x60; - Завершена * &#x60;HIDDEN&#x60; - Скрыта
     * @param {string} [titleIcontains] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksCompletedList(assignedTo?: number, assignedToLastNameIcontains?: string, assignedToUsernameIexact?: string, createdByLastNameIcontains?: string, createdByUsername?: string, deadlineGte?: string, deadlineLte?: string, descriptionIcontains?: string, obligation?: number, obligationResponsibilityTypeTitleIexact?: string, status?: TasksCompletedListStatusEnum, titleIcontains?: string, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksCompletedList(assignedTo, assignedToLastNameIcontains, assignedToUsernameIexact, createdByLastNameIcontains, createdByUsername, deadlineGte, deadlineLte, descriptionIcontains, obligation, obligationResponsibilityTypeTitleIexact, status, titleIcontains, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Task} task 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksCreate(task: Task, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksCreate(task, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Задача.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksDestroy(id: number, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [assignedTo] 
     * @param {string} [assignedToLastNameIcontains] 
     * @param {string} [assignedToUsernameIexact] 
     * @param {string} [createdByLastNameIcontains] 
     * @param {string} [createdByUsername] 
     * @param {string} [deadlineGte] 
     * @param {string} [deadlineLte] 
     * @param {string} [descriptionIcontains] 
     * @param {number} [obligation] 
     * @param {string} [obligationResponsibilityTypeTitleIexact] 
     * @param {TasksListStatusEnum} [status] * &#x60;NOT_STARTED&#x60; - Не начата * &#x60;IN_PROGRESS&#x60; - В работе * &#x60;COMPLETED&#x60; - Завершена * &#x60;HIDDEN&#x60; - Скрыта
     * @param {string} [titleIcontains] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksList(assignedTo?: number, assignedToLastNameIcontains?: string, assignedToUsernameIexact?: string, createdByLastNameIcontains?: string, createdByUsername?: string, deadlineGte?: string, deadlineLte?: string, descriptionIcontains?: string, obligation?: number, obligationResponsibilityTypeTitleIexact?: string, status?: TasksListStatusEnum, titleIcontains?: string, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksList(assignedTo, assignedToLastNameIcontains, assignedToUsernameIexact, createdByLastNameIcontains, createdByUsername, deadlineGte, deadlineLte, descriptionIcontains, obligation, obligationResponsibilityTypeTitleIexact, status, titleIcontains, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [assignedTo] 
     * @param {string} [assignedToLastNameIcontains] 
     * @param {string} [assignedToUsernameIexact] 
     * @param {string} [createdByLastNameIcontains] 
     * @param {string} [createdByUsername] 
     * @param {string} [deadlineGte] 
     * @param {string} [deadlineLte] 
     * @param {string} [descriptionIcontains] 
     * @param {number} [obligation] 
     * @param {string} [obligationResponsibilityTypeTitleIexact] 
     * @param {TasksMyCompletedListStatusEnum} [status] * &#x60;NOT_STARTED&#x60; - Не начата * &#x60;IN_PROGRESS&#x60; - В работе * &#x60;COMPLETED&#x60; - Завершена * &#x60;HIDDEN&#x60; - Скрыта
     * @param {string} [titleIcontains] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksMyCompletedList(assignedTo?: number, assignedToLastNameIcontains?: string, assignedToUsernameIexact?: string, createdByLastNameIcontains?: string, createdByUsername?: string, deadlineGte?: string, deadlineLte?: string, descriptionIcontains?: string, obligation?: number, obligationResponsibilityTypeTitleIexact?: string, status?: TasksMyCompletedListStatusEnum, titleIcontains?: string, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksMyCompletedList(assignedTo, assignedToLastNameIcontains, assignedToUsernameIexact, createdByLastNameIcontains, createdByUsername, deadlineGte, deadlineLte, descriptionIcontains, obligation, obligationResponsibilityTypeTitleIexact, status, titleIcontains, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [assignedTo] 
     * @param {string} [assignedToLastNameIcontains] 
     * @param {string} [assignedToUsernameIexact] 
     * @param {string} [createdByLastNameIcontains] 
     * @param {string} [createdByUsername] 
     * @param {string} [deadlineGte] 
     * @param {string} [deadlineLte] 
     * @param {string} [descriptionIcontains] 
     * @param {number} [obligation] 
     * @param {string} [obligationResponsibilityTypeTitleIexact] 
     * @param {TasksMyListStatusEnum} [status] * &#x60;NOT_STARTED&#x60; - Не начата * &#x60;IN_PROGRESS&#x60; - В работе * &#x60;COMPLETED&#x60; - Завершена * &#x60;HIDDEN&#x60; - Скрыта
     * @param {string} [titleIcontains] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksMyList(assignedTo?: number, assignedToLastNameIcontains?: string, assignedToUsernameIexact?: string, createdByLastNameIcontains?: string, createdByUsername?: string, deadlineGte?: string, deadlineLte?: string, descriptionIcontains?: string, obligation?: number, obligationResponsibilityTypeTitleIexact?: string, status?: TasksMyListStatusEnum, titleIcontains?: string, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksMyList(assignedTo, assignedToLastNameIcontains, assignedToUsernameIexact, createdByLastNameIcontains, createdByUsername, deadlineGte, deadlineLte, descriptionIcontains, obligation, obligationResponsibilityTypeTitleIexact, status, titleIcontains, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Задача.
     * @param {PatchedTask} [patchedTask] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksPartialUpdate(id: number, patchedTask?: PatchedTask, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksPartialUpdate(id, patchedTask, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Задача.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Задача.
     * @param {Task} task 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksUpdate(id: number, task: Task, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksUpdate(id, task, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const TasksCompletedListStatusEnum = {
    Completed: 'COMPLETED',
    Hidden: 'HIDDEN',
    InProgress: 'IN_PROGRESS',
    NotStarted: 'NOT_STARTED'
} as const;
export type TasksCompletedListStatusEnum = typeof TasksCompletedListStatusEnum[keyof typeof TasksCompletedListStatusEnum];
/**
 * @export
 */
export const TasksListStatusEnum = {
    Completed: 'COMPLETED',
    Hidden: 'HIDDEN',
    InProgress: 'IN_PROGRESS',
    NotStarted: 'NOT_STARTED'
} as const;
export type TasksListStatusEnum = typeof TasksListStatusEnum[keyof typeof TasksListStatusEnum];
/**
 * @export
 */
export const TasksMyCompletedListStatusEnum = {
    Completed: 'COMPLETED',
    Hidden: 'HIDDEN',
    InProgress: 'IN_PROGRESS',
    NotStarted: 'NOT_STARTED'
} as const;
export type TasksMyCompletedListStatusEnum = typeof TasksMyCompletedListStatusEnum[keyof typeof TasksMyCompletedListStatusEnum];
/**
 * @export
 */
export const TasksMyListStatusEnum = {
    Completed: 'COMPLETED',
    Hidden: 'HIDDEN',
    InProgress: 'IN_PROGRESS',
    NotStarted: 'NOT_STARTED'
} as const;
export type TasksMyListStatusEnum = typeof TasksMyListStatusEnum[keyof typeof TasksMyListStatusEnum];


/**
 * TokenApi - axios parameter creator
 * @export
 */
export const TokenApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} tokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenCreate: async (tokenObtainPair: TokenObtainPair, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenObtainPair' is not null or undefined
            assertParamExists('tokenCreate', 'tokenObtainPair', tokenObtainPair)
            const localVarPath = `/api/token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenObtainPair, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenRefreshCreate: async (tokenRefresh: TokenRefresh, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRefresh' is not null or undefined
            assertParamExists('tokenRefreshCreate', 'tokenRefresh', tokenRefresh)
            const localVarPath = `/api/token/refresh/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRefresh, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenApi - functional programming interface
 * @export
 */
export const TokenApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenApiAxiosParamCreator(configuration)
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} tokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenCreate(tokenObtainPair: TokenObtainPair, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenObtainPair>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenCreate(tokenObtainPair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokenApi.tokenCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenRefreshCreate(tokenRefresh: TokenRefresh, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenRefresh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenRefreshCreate(tokenRefresh, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokenApi.tokenRefreshCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TokenApi - factory interface
 * @export
 */
export const TokenApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokenApiFp(configuration)
    return {
        /**
         * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
         * @param {TokenObtainPair} tokenObtainPair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenCreate(tokenObtainPair: TokenObtainPair, options?: RawAxiosRequestConfig): AxiosPromise<TokenObtainPair> {
            return localVarFp.tokenCreate(tokenObtainPair, options).then((request) => request(axios, basePath));
        },
        /**
         * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenRefreshCreate(tokenRefresh: TokenRefresh, options?: RawAxiosRequestConfig): AxiosPromise<TokenRefresh> {
            return localVarFp.tokenRefreshCreate(tokenRefresh, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokenApi - object-oriented interface
 * @export
 * @class TokenApi
 * @extends {BaseAPI}
 */
export class TokenApi extends BaseAPI {
    /**
     * Takes a set of user credentials and returns an access and refresh JSON web token pair to prove the authentication of those credentials.
     * @param {TokenObtainPair} tokenObtainPair 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public tokenCreate(tokenObtainPair: TokenObtainPair, options?: RawAxiosRequestConfig) {
        return TokenApiFp(this.configuration).tokenCreate(tokenObtainPair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Takes a refresh type JSON web token and returns an access type JSON web token if the refresh token is valid.
     * @param {TokenRefresh} tokenRefresh 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenApi
     */
    public tokenRefreshCreate(tokenRefresh: TokenRefresh, options?: RawAxiosRequestConfig) {
        return TokenApiFp(this.configuration).tokenRefreshCreate(tokenRefresh, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreate: async (user: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersCreate', 'user', user)
            const localVarPath = `/api/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this пользователь.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDestroy: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersDestroy', 'id', id)
            const localVarPath = `/api/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/me/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this пользователь.
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate: async (id: number, patchedUser?: PatchedUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersPartialUpdate', 'id', id)
            const localVarPath = `/api/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this пользователь.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersRetrieve', 'id', id)
            const localVarPath = `/api/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this пользователь.
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate: async (id: number, user: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersUpdate', 'id', id)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersUpdate', 'user', user)
            const localVarPath = `/api/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication jwtAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCreate(user: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCreate(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this пользователь.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersDestroy(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersDestroy(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersMeRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersMeRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersMeRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this пользователь.
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPartialUpdate(id: number, patchedUser?: PatchedUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPartialUpdate(id, patchedUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this пользователь.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersRetrieve(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersRetrieve(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this пользователь.
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUpdate(id: number, user: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUpdate(id, user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.usersUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreate(user: User, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersCreate(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this пользователь.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDestroy(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersList(options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.usersList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersMeRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this пользователь.
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPartialUpdate(id: number, patchedUser?: PatchedUser, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersPartialUpdate(id, patchedUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this пользователь.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve(id: number, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this пользователь.
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdate(id: number, user: User, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.usersUpdate(id, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersCreate(user: User, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersCreate(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this пользователь.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersDestroy(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersList(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersMeRetrieve(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersMeRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this пользователь.
     * @param {PatchedUser} [patchedUser] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPartialUpdate(id: number, patchedUser?: PatchedUser, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPartialUpdate(id, patchedUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this пользователь.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersRetrieve(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this пользователь.
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUpdate(id: number, user: User, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUpdate(id, user, options).then((request) => request(this.axios, this.basePath));
    }
}



